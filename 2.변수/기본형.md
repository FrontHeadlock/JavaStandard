### 비트와 바이트

비트  : 한 자리의 2진수를 '비트'라고 하며, 1 비트는 CPU가 값을 저장할 수 있는 최소 단위

바이트 : 1비트 8개를 묶어서 '바이트'라는 단위로 정의해 데이터의 기본 단위로 사용한다

워드  : CPU가 한 번에 처리할 수 있는 데이터의 크기(워드는 CPU 성능에 따라 다름, 64bit CPU 기준 1워드는 64비트)

---

# 기본형


- 논리형 Boolean
    - true와 false 중 하나를 저장 가능하며, 기본값은 false
    - (true/false) 등의 논리구현에 주로 사용
    - Java에서 데이터를 다루는 최소 단위가 byte이기 때문에 boolean의 크기도 1byte
<br><br/>

- 문자형 Char
    - 문자를 저장하기 위한 변수 선언 시 사용, 단 하나만의 문자를 저장할 수 있다.
    - Com은 숫자만 인식하기 때문에, 문자의 원형이 아닌 문자의 유니코드('A'=65)가 저장된다.
    - 형변환(캐스팅)
        - 어떤 타입을 다른 타입으로 변환하는 것
        - String : " "
        - Char   : ' '
        
        ```java
            char ch = 'A'
            int code = (int)ch;
            System.out.printf("%c = %d",ch, code); // A = 65
        ```
    - 특수문자 다루기
        - \t : tab
        - \b : backspace
        - \n : new line
        
        ```java
            System.out.println('\'');  // '  출력 :  ' '로 문자열을 감싸고, \(이스케이프) '(값) 출력
            System.out.println("\\t"); // \t 출력 : 문자 \t 출력 \(이스케이프) \t 출력
            System.out.println('\t');  // 탭  출력 : 탭으로 출력(1칸 들여쓰기) 
        ```
    - 인코딩과 디코딩
        - 문자 인코딩
            - 문자 'A'를 유니코드로 인코딩하면 65로 변환
        - 문자 디코딩
            - 65를 문자로 변환시 'A'
    
    - 아스키 코드, 유니코드
        - 아스키코드 

            : 미국에서 만든 문자 인코딩 표준 (영어, 알파벳, 특수문자, 제어문자 포함)

            : 7비트로 구성 -> 128개 문자 표현

        - 유니코드

            : 전 세계 모든 문자를 하나의 표준으로 통합하기 위해 만들어진 인코딩
            
            : 각 문자에 고유한 번호를 부여

- 정수형
    - byte(1) < short(2) < int(4) < long(8)
    - byte : -128 ~ 127
    - short: -32,768 ~ 32,767
    - int  : -2,147,483,648 ~ 2,147,483,647 (약 20억)
    - long : -2^63 ~ 2^63-1
    - 정수형 선택시 기본 값으로 int를 선택하는 이유

        : JVM의 피연산자 스택이 4byte 단위기 때문
        : byte or short의 경우 4byte로 변환하여 연산이 수행되기에 오히려 비효율적일 수 있다.

- 실수형
    - float : 32bit(4byte)크기, 1.4 * 10^-45 ~ 3.4 * 10^38 , 정밀도 7자리
    - doube : 64bit(8byte)크기, 4.9 * 10^-324 ~ 1.8 * 10^308, 정밀도 14자리
    - 실수형에서의 Overflow
        - 정수형에서의 overflow는 표현범위를 벗어나는 것
        - 실수형에서 overflow 발생 시에는 정수형과 달리 변수의 값이 무한대가 됨
        - 실수형에는 정수형에 없는 underflow가 존재 (실수형으로 표현할 수 없는 아주 작은 값 -> 변수가 0으로 됨)
    - 표현형식
        - 정수형 : 부호와 값
        - 실수형 : 부호(S), 지수(E), 가수(M)   
            : 10의 제곱을 곱한 형태(±M X 10^E)
    - 정밀도

        : 정밀도 n에 대하여 n자리의 10진수를 오차없이 저장할 수 있다.
        : 실수형에서 보통 double을 사용하는 것은 정밀도 문제가 큼

<br>
<br/>

- 형변환
    > 💡 **형변환**이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
    - 형변환 방법

        ```java
        (Type) 피연산자
        ```
        - 괄호  : 캐스트 연산자 or 형변환 연산자
        - 형변환 : 캐스팅
        - 형변환 연산자는 피연산자의 값을 읽어 지정된 타입으로 결과만 반환, 피연산자의 값은 형변환에 영향받지 않는다
    
        | 변환         | 수식            | 결과  |
        |--------------|-----------------|-------|
        | int → char | (char) 65     | 'A' |
        | char → int | (int) 'A'     | 65  |
        | float → int| (int) 1.6f    | 1   |
        | int → float| (float) 10    | 10.0f |

<br>
<br/>

- 정수형 간의 형변환
    - int -> byte
        - 값 손실 발생

- 실수형 간의 형변환
    - float -> double
        - 남은자리 0으로 채움
    - double -> float
        - 값 손실, 52자리 중 23자리만 저장 나머지는 버려짐

- 정수형 과 실수형 간의 형변환
    - 정수형 -> 실수형 : 문제 X, 다만 정밀도만 고려할 사항
    - 실수형 -> 정수형 : 반올림 발생 X, 실수의 소수점을 버리고 남은 정수에 대한 사이즈만 고려

- 자동 형변환
    ```java
    int i=3;
    double d= 1.0 + i;  //(double)i에서 (double) 형변환이 생략됨
    ```
    - 규칙
        - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
        - byte < short < int < long < float < double
        - boolean을 제외한 나머지 7개 기본형은 서로 형변환 가능
        - 기본형과 참조형은 서로 형변환 X
        - 서로 다른 타입의 변수간 연산은 형변환이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략 가능
